import json
from pathlib import Path
from datetime import datetime
from .schema import ToolSchema
from textwrap import dedent


class WorkflowManager(ToolSchema):
    """
    Manages multi-command workflows for complex DevOps tasks.
    Can generate shell scripts for multi-step operations and save them as reusable templates.
    """
    
    def __init__(self):
        self.name = "workflow_manager"
        self.workflows_dir = Path.home() / ".shellmind" / "workflows"
        self.workflows_dir.mkdir(parents=True, exist_ok=True)
    
    def description(self):
        return dedent("""
        Manages multi-command workflows for complex DevOps tasks.
        
        Use this tool to:
        - Create shell scripts that combine multiple commands into a single workflow
        - Save workflows as reusable templates with descriptive names
        - List available saved workflows
        - Load and execute saved workflows
        - Delete workflows that are no longer needed
        
        Workflows are stored in ~/.shellmind/workflows/ as executable shell scripts.
        Each workflow includes:
        - Descriptive header comments
        - Error handling (set -e to stop on first error)
        - Command grouping with comments
        - Execution timestamps
        
        Actions:
        - 'create': Generate a new workflow from a list of commands
        - 'save': Save the generated workflow as a template
        - 'list': List all saved workflows
        - 'load': Load a saved workflow by name
        - 'delete': Delete a saved workflow
        - 'execute': Generate and immediately offer to execute a workflow
        
        Examples:
        - Create a deployment workflow with build, test, and deploy steps
        - Save a database backup workflow for regular use
        - Create a system health check workflow
        """)
    
    def json_schema(self):
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description(),
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "enum": ["create", "save", "list", "load", "delete", "execute"],
                            "description": "The workflow action to perform"
                        },
                        "name": {
                            "type": "string",
                            "description": "Name of the workflow (for save/load/delete actions)"
                        },
                        "description": {
                            "type": "string",
                            "description": "Description of what the workflow does"
                        },
                        "commands": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "command": {
                                        "type": "string",
                                        "description": "The shell command to execute"
                                    },
                                    "description": {
                                        "type": "string",
                                        "description": "What this command does"
                                    }
                                },
                                "required": ["command"]
                            },
                            "description": "List of commands with optional descriptions"
                        },
                        "stop_on_error": {
                            "type": "boolean",
                            "description": "Whether to stop execution if a command fails (default: true)",
                            "default": True
                        }
                    },
                    "required": ["action"]
                }
            }
        }
    
    def _generate_script(self, commands: list, description: str = "", stop_on_error: bool = True) -> str:
        """Generate a shell script from a list of commands."""
        script_lines = [
            "#!/bin/bash",
            "",
            f"# Generated by ShellMind on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        ]
        
        if description:
            script_lines.append(f"# {description}")
        
        script_lines.extend([
            "",
            "# Configuration",
        ])
        
        if stop_on_error:
            script_lines.append("set -e  # Exit on first error")
        
        script_lines.extend([
            "set -u  # Exit on undefined variable",
            "set -o pipefail  # Exit on pipe failure",
            "",
            "# Colors for output",
            'GREEN="\\033[0;32m"',
            'YELLOW="\\033[1;33m"',
            'RED="\\033[0;31m"',
            'NC="\\033[0m"  # No Color',
            "",
            "# Helper functions",
            "log_info() {",
            '    echo -e "${GREEN}[INFO]${NC} $1"',
            "}",
            "",
            "log_warning() {",
            '    echo -e "${YELLOW}[WARNING]${NC} $1"',
            "}",
            "",
            "log_error() {",
            '    echo -e "${RED}[ERROR]${NC} $1"',
            "}",
            "",
            "# Workflow execution",
            'log_info "Starting workflow execution..."',
            'START_TIME=$(date +%s)',
            "",
        ])
        
        # Add each command with logging
        for i, cmd_obj in enumerate(commands, 1):
            if isinstance(cmd_obj, dict):
                command = cmd_obj.get("command", "")
                cmd_description = cmd_obj.get("description", "")
            else:
                command = str(cmd_obj)
                cmd_description = ""
            
            script_lines.append(f"# Step {i}{': ' + cmd_description if cmd_description else ''}")
            script_lines.append(f'log_info "Step {i}: {cmd_description or command[:50]}"')
            script_lines.append(f"{command}")
            
            if not stop_on_error:
                script_lines.extend([
                    "if [ $? -ne 0 ]; then",
                    f'    log_warning "Step {i} failed, but continuing..."',
                    "fi"
                ])
            
            script_lines.append("")
        
        # Add completion message
        script_lines.extend([
            'END_TIME=$(date +%s)',
            'DURATION=$((END_TIME - START_TIME))',
            'log_info "Workflow completed successfully in ${DURATION} seconds"',
        ])
        
        return "\n".join(script_lines)
    
    def _save_workflow(self, name: str, script_content: str, description: str = "") -> dict:
        """Save a workflow script to disk."""
        # Sanitize the workflow name
        safe_name = "".join(c for c in name if c.isalnum() or c in ("-", "_")).lower()
        if not safe_name:
            return {
                "success": False,
                "error": "Invalid workflow name. Use only alphanumeric characters, hyphens, and underscores."
            }
        
        workflow_path = self.workflows_dir / f"{safe_name}.sh"
        metadata_path = self.workflows_dir / f"{safe_name}.json"
        
        try:
            # Save the script
            workflow_path.write_text(script_content)
            workflow_path.chmod(0o755)  # Make executable
            
            # Save metadata
            metadata = {
                "name": name,
                "description": description,
                "created": datetime.now().isoformat(),
                "path": str(workflow_path)
            }
            metadata_path.write_text(json.dumps(metadata, indent=2))
            
            return {
                "success": True,
                "message": f"Workflow '{name}' saved successfully",
                "path": str(workflow_path),
                "metadata": metadata
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to save workflow: {str(e)}"
            }
    
    def _list_workflows(self) -> dict:
        """List all saved workflows."""
        workflows = []
        
        for script_file in self.workflows_dir.glob("*.sh"):
            metadata_file = script_file.with_suffix(".json")
            
            if metadata_file.exists():
                try:
                    metadata = json.loads(metadata_file.read_text())
                    workflows.append(metadata)
                except Exception:
                    # If metadata is corrupted, just use the filename
                    workflows.append({
                        "name": script_file.stem,
                        "description": "No description available",
                        "path": str(script_file)
                    })
        
        return {
            "success": True,
            "count": len(workflows),
            "workflows": workflows
        }
    
    def _load_workflow(self, name: str) -> dict:
        """Load a saved workflow."""
        safe_name = "".join(c for c in name if c.isalnum() or c in ("-", "_")).lower()
        workflow_path = self.workflows_dir / f"{safe_name}.sh"
        metadata_path = self.workflows_dir / f"{safe_name}.json"
        
        if not workflow_path.exists():
            return {
                "success": False,
                "error": f"Workflow '{name}' not found"
            }
        
        try:
            script_content = workflow_path.read_text()
            metadata = {}
            
            if metadata_path.exists():
                metadata = json.loads(metadata_path.read_text())
            
            return {
                "success": True,
                "name": name,
                "script": script_content,
                "path": str(workflow_path),
                "metadata": metadata
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to load workflow: {str(e)}"
            }
    
    def _delete_workflow(self, name: str) -> dict:
        """Delete a saved workflow."""
        safe_name = "".join(c for c in name if c.isalnum() or c in ("-", "_")).lower()
        workflow_path = self.workflows_dir / f"{safe_name}.sh"
        metadata_path = self.workflows_dir / f"{safe_name}.json"
        
        if not workflow_path.exists():
            return {
                "success": False,
                "error": f"Workflow '{name}' not found"
            }
        
        try:
            workflow_path.unlink()
            if metadata_path.exists():
                metadata_path.unlink()
            
            return {
                "success": True,
                "message": f"Workflow '{name}' deleted successfully"
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to delete workflow: {str(e)}"
            }
    
    def run(self, action: str, name: str = None, description: str = "", 
            commands: list = None, stop_on_error: bool = True):
        """
        Execute a workflow management action.
        
        Args:
            action: The action to perform (create, save, list, load, delete, execute)
            name: Workflow name (required for save, load, delete)
            description: Workflow description
            commands: List of commands for create/execute/save
            stop_on_error: Whether to stop on first error
            
        Returns:
            JSON string with results
        """
        if action == "list":
            result = self._list_workflows()
            return json.dumps(result, indent=2)
        
        if action == "load":
            if not name:
                return json.dumps({
                    "success": False,
                    "error": "Workflow name is required for 'load' action"
                }, indent=2)
            result = self._load_workflow(name)
            return json.dumps(result, indent=2)
        
        if action == "delete":
            if not name:
                return json.dumps({
                    "success": False,
                    "error": "Workflow name is required for 'delete' action"
                }, indent=2)
            result = self._delete_workflow(name)
            return json.dumps(result, indent=2)
        
        if action in ["create", "execute", "save"]:
            if not commands or not isinstance(commands, list):
                return json.dumps({
                    "success": False,
                    "error": f"Commands list is required for '{action}' action"
                }, indent=2)
            
            # Generate the script
            script = self._generate_script(commands, description, stop_on_error)
            
            if action == "create":
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "script": script,
                    "message": "Workflow script generated. Use 'save' action to save it as a template."
                }, indent=2)
            
            elif action == "execute":
                return json.dumps({
                    "success": True,
                    "action": "execute",
                    "script": script,
                    "message": "Workflow script generated. You can now execute it using the run_command tool.",
                    "suggestion": "To execute, save this to a file and run it, or use run_command with the generated script."
                }, indent=2)
            
            elif action == "save":
                if not name:
                    return json.dumps({
                        "success": False,
                        "error": "Workflow name is required for 'save' action"
                    }, indent=2)
                result = self._save_workflow(name, script, description)
                return json.dumps(result, indent=2)
        
        return json.dumps({
            "success": False,
            "error": f"Unknown action: {action}"
        }, indent=2)

